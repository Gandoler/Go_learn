# Срезы (Slices) в Go

Срезы (slices) — это основной способ работы с коллекциями переменной длины в Go.
В отличие от массивов, срезы **не фиксируют количество элементов в типе** и позволяют изменять длину коллекции.
По сути это аналог списков из других языков.

> По-английски: `slices`.

---

## Структура среза

Технически срез — это обёртка над массивом. Он хранит три вещи:

1. Указатель на первый элемент.
2. Текущую длину (`len()`).
3. Вместимость (`cap()`) — максимальное количество элементов без выделения нового массива.

---

## Объявление среза

```go
var nums []int
````

> Значение по умолчанию — `nil`.

Срез можно создать с помощью литерала:

```go
numbers := []int{10, 20, 30}
fmt.Println(numbers)	    // => [10 20 30]
fmt.Println(len(numbers)) // => 3
```

Пустой срез:

```go
var empty []string{}
fmt.Println(empty)      // => []
fmt.Println(len(empty)) // => 0
```

> Пустой срез — не `nil`, но ведёт себя как пустая коллекция.

---

## Создание среза через `make`

```go
nums := make([]int, 5) // длина = 5, вместимость = 5
fmt.Println(nums)       // => [0 0 0 0 0]
```

Можно задать вместимость больше длины:

```go
buffer := make([]int, 0, 1000) // длина 0, вместимость 1000
fmt.Println(len(buffer))       // => 0
fmt.Println(cap(buffer))       // => 1000
```

> Это позволяет избежать постоянного выделения новой памяти при `append()`.

---

## Добавление элементов

```go
nums := []int{1, 2}
nums = append(nums, 3)
fmt.Println(nums) // => [1 2 3]
```

Добавление нескольких элементов:

```go
nums = append(nums, 2, 3, 4)
fmt.Println(nums) // => [1 2 3 4]
```

Объединение срезов:

```go
a := []int{1, 2}
b := []int{3, 4}
a = append(a, b...)
fmt.Println(a) // => [1 2 3 4]
```

---

## Доступ к элементам

```go
nums := []int{5, 6, 7}
fmt.Println(nums[1]) // 6

nums[2] = 100
fmt.Println(nums)    // [5 6 100]
```

> Если обратиться по индексу вне диапазона — `panic: index out of range`.

---

## Передача и возврат из функции

Срезы передаются по значению, но **значение содержит указатель на массив**, поэтому изменения внутри функции отражаются на оригинале.

```go
func changeAndReturn(s []int) []int {
	s[0] = 999
	return s
}

func main() {
	data := []int{1, 2, 3}
	result := changeAndReturn(data)
	fmt.Println(result) // => [999 2 3]
	fmt.Println(data)   // => [999 2 3]
}
```

---

## Пример: заполнение среза в цикле и возврат

```go
func squares(n int) []int {
	nums := []int{}
	for i := 1; i <= n; i++ {
		nums = append(nums, i*i)
	}
	return nums
}

func main() {
	result := squares(5)
	fmt.Println(result) // => [1 4 9 16 25]
```
