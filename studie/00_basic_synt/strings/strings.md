# Строки в Go

В Go строки представлены типом `string`. Это **неизменяемая последовательность байт**, закодированных в UTF-8.  
Строки — один из самых часто используемых типов данных, особенно при работе с текстами, запросами, HTTP и файловыми путями.

## Объявление строк

```go
var name string = "Hexlet"

// Сокращённая форма через вывод типа
greeting := "Hello"
````

Обычные строки записываются в **двойных кавычках**.
Но если строка многострочная или содержит спецсимволы (например, `\n` или кавычки), удобнее использовать **сырые литералы** — через обратные кавычки:

```go
sql := `
	SELECT *
	FROM users
	WHERE active = true
`
```

В таких строках сохраняются все отступы, переносы и символы как есть, без экранирования.

---

## Конкатенация

Объединить строки можно с помощью оператора `+`:

```go
"hello " + "world" // "hello world"
```

Go поддерживает сокращённый синтаксис при использовании переменных:

```go
text := "Hello"
text += " World"
fmt.Println(text) // Hello World
```

⚠️ Конкатенация возможна **только между значениями типа string**.
Смешивание типов приведёт к ошибке компиляции:

```go
name := "Hexlet"
age := 10

// name + age // ошибка: mismatched types string and int
```

---

## Преобразование чисел в строки

В Go числа **не конвертируются в строки автоматически**.
Более того, выражение `string(number)` **не** преобразует число в текстовое представление.
Вместо этого число рассматривается как код Unicode, и результатом будет символ с этим кодом.

Примеры:

```go
fmt.Println(string(65))  // "A", так как 65 — код символа 'A'
fmt.Println(string(49))  // "1", так как 49 — код символа '1'
fmt.Println(string(5))   // непечатаемый символ
```

Чтобы получить строку с текстовым значением числа, нужно использовать пакет **strconv**:

```go
import "strconv"

count := 5
msg := "You have " + strconv.Itoa(count) + " new messages"
fmt.Println(msg) // "You have 5 new messages"
```

Для чисел с плавающей точкой применяется `strconv.FormatFloat`:

```go
pi := 3.14
msg := "Pi is approximately " + strconv.FormatFloat(pi, 'f', 2, 64)
fmt.Println(msg) // "Pi is approximately 3.14"
```

---

## Форматирование строк

Go не поддерживает **интерполяцию строк** напрямую.
Вместо этого используется функция `fmt.Sprintf()`, которая работает по шаблону:

```go
import "fmt"

name := "Hexlet"
msg := fmt.Sprintf("Hello, %s!", name) // "Hello, Hexlet!"
```

---

## Длина строки

Для определения длины строки используется встроенная функция `len()`:

```go
len("hexlet") // 6
```

⚠️ Строки в Go — это последовательности **байт**, а не символов.
Один символ в UTF-8 (например, кириллический или emoji) может занимать 2–4 байта:

```go
len("го")    // 4 (по 2 байта на символ)
len("😀")    // 4
len("hello") // 5
```

Чтобы корректно работать с символами, а не байтами, существует тип **rune**.
`rune` — это псевдоним для `int32`, обозначающий один Unicode-символ.

Для подсчёта количества символов используется `utf8.RuneCountInString()`:

```go
import "unicode/utf8"

utf8.RuneCountInString("хекслет") // 6
```

---

## Обращение к символам

Строка в Go — это **массив байт**.
При обращении по индексу (`s[i]`) возвращается байт, а не символ:

```go
s := "Привет"

// первый байт
fmt.Println(s[0]) // => 208

// некорректный символ
fmt.Printf("%c\n", s[0]) // => Ð
```

Чтобы получить символ, строку нужно преобразовать в срез рун:

```go
runes := []rune("Привет")

// код точки Unicode
fmt.Println(runes[0])        // => 1055
fmt.Printf("%c\n", runes[0]) // => П
```
